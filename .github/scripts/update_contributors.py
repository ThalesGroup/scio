"""Parse ``CONTRIBUTORS.md`` and update ``docs/src/contributors.rst."""

import html
import os
import re
from operator import itemgetter
from pathlib import Path
from types import MappingProxyType

CONTRIBUTORS_MD = Path(__file__).parent.parent.parent / "CONTRIBUTORS.md"
CONTRIBUTORS_RST = (
    Path(__file__).parent.parent.parent / "docs" / "src" / "contributors.rst"
)

# Map known contributions to emojis (extend as needed)
EMOJI_MAP = MappingProxyType({
    "answering questions": '<span title="Answering questions">💬</span>',
    "bug reports": '<span title="Bug reports">🐛</span>',
    "code": '<span title="Code">💻</span>',
    "dissemination": '<span title="Dissemination">📢</span>',
    "documentation": '<span title="Documentation">📚</span>',
    "fixes": '<span title="Fixes">🛠️</span>',
    "ideas": '<span title="Ideas">💡</span>',
    "infrastructure": '<span title="Infrastructure">🧱</span>',
    "maintenance": '<span title="Maintenance">🚧</span>',
    "pr reviews": '<span title="PR reviews">👀</span>',
    "research": '<span title="Research">🔬</span>',
    "testing": '<span title="Testing">⚙️</span>',
    "tutorials": '<span title="Tutorials">🎓</span>',
})

# Markers in CONTRIBUTORS.md and docs/src/contributors.rst
TABLE_START = "<!-- TABLE START -->"
TABLE_END = "<!-- TABLE END -->"
HTML_START = ".. HTML START"
HTML_END = ".. HTML END"


type Entry = tuple[str, tuple[str, ...], tuple[str, str]]


def parse_contributors_table(path: Path) -> tuple[Entry, ...]:
    """Find manual entries and parse the table.

    Not very robust on purpose, expects a precise format. See example
    below for output specification.

    Example
    -------
    Sample output::

        (
            ("alice", ("code", "documentation", "fixes"), ("Smith", "Alice")),
            ("bob", ("fixes",), ("Lee", "Bob")),
            ("noname", (), ("", "")),
        )

    """
    content = path.read_text(encoding="utf-8")
    pattern = f"{re.escape(TABLE_START)}\n(.*)\n{re.escape(TABLE_END)}\n$"
    entries_str = re.search(pattern, content, re.DOTALL).group(1).split("\n")[2:]
    entries_tpl = tuple(
        tuple(map(str.strip, entry.split("|")[1:-1])) for entry in entries_str
    )
    return tuple(
        (
            username,
            tuple(map(str.strip, contrib_str.split(","))) if contrib_str else (),
            tuple(map(str.strip, itemgetter(0, 2)(name_str.partition(",")))),
        )
        for username, contrib_str, name_str in entries_tpl
    )


LAST_CHAR = chr(0x10FFFF)


def sort_key(entry: Entry) -> tuple[str, str, str, int]:
    """Generate sort key for given entry."""
    username, contributions, (lastname, firstname) = entry
    if not username:
        msg = f"Contributor entries require at least a username. Invalid entry: {entry}"
        raise ValueError(msg)

    return (
        lastname or LAST_CHAR,
        firstname or LAST_CHAR,
        username,
        -len(contributions),
    )


RAW_HTML = ".. raw:: html"
INDENT = "   "


def generate_html(entries: tuple[Entry, ...]) -> str:
    """Generate HTML content corresponding to parsed entries."""
    lines = []
    lines.append(
        '<div style="display: flex; flex-wrap: wrap; justify-content: flex-start;">',
    )

    for username_raw, contributions, (lastname, firstname) in entries:
        username = html.escape(username_raw)
        emojis = " ".join(EMOJI_MAP[contrib] for contrib in contributions)
        name = html.escape(f"{firstname} {lastname}".strip())
        avatar_url = f"https://github.com/{username}.png"

        lines.extend(
            f"""  <div align="center" style="width: 16.66%; padding: 0.7%;">
    <img src="{avatar_url}" width="100%" alt="@{username}" style="border-radius: 5%;">
    <p>
      {f"<strong>{name}</strong><br/>" if name else ""}
      <a href="https://github.com/{username}" style="font-family: monospace;
         font-size: 0.9em;">
        @{username}
      </a><br/>
      {emojis}
    </p>
  </div>
""".split("\n"),
        )

    auto_gen_info = (
        '<i>This HTML content was automatically generated by parsing <a href="'
        f'{get_contributors_md_url()}"><code>CONTRIBUTING.md</code></a>.</i>'
    )
    lines.extend(["</div>", "", auto_gen_info])
    lines_indented = (f"{INDENT}{line}".rstrip() for line in lines)
    return "\n".join(["", RAW_HTML, "", *lines_indented, ""])


def update_contributors_md(path: Path, entries: tuple[Entry, ...]) -> None:
    """Parse ``CONTRIBUTORS.md`` bottom table & update HTML content."""
    content = path.read_text(encoding="utf-8")
    html = generate_html(sorted(entries, key=sort_key))

    pattern = f"^(.*{re.escape(HTML_START)}).*({re.escape(HTML_END)}.*)$"
    new_content = html.join(re.search(pattern, content, re.DOTALL).group(1, 2))

    if new_content != content:
        path.write_text(new_content, encoding="utf-8")


def get_contributors_md_url() -> str:
    """Explicit. For RTD builds.

    Taken from ``conf.py``.
    """
    github_url = "https://github.com/ThalesGroup/scio"
    ref = (  # Commit hash for PR builds, else checked out branch
        os.environ["READTHEDOCS_GIT_COMMIT_HASH"]
        if os.environ.get("READTHEDOCS_VERSION_TYPE", "") == "external"
        else os.environ.get("READTHEDOCS_GIT_IDENTIFIER", "develop")
    )
    return f"{github_url}/blob/{ref}/CONTRIBUTORS.md"


if __name__ == "__main__":
    entries = parse_contributors_table(CONTRIBUTORS_MD)
    update_contributors_md(CONTRIBUTORS_RST, entries)
